---
title: "The Procedural Generation: From Randomness to Realism"
type: "article"
description: "Learn how procedural generation uses algorithms to craft unique landscapes, textures, and environments through hands-on examples"
date: 2024-11-05
image: /images/procedural-generation.jpg
tags: ["procedural generation", "beginner friendly"]
category: Computer graphics
index: []
published: true
---

Procedural generation is a technique used in game development to create content algorithmically 
instead of manually. It allows developers to produce environments, objects, and experiences that 
feel organic without designing every element by hand. This approach has transformed how games are 
built, balancing creativity with automation.

# Examples

- ## World generation <br />
  <ImagesGrid columns={2} images={[{src:"/images/blog/procedural-generation/2.webp"}, {src:"/images/blog/procedural-generation/1.png"}]} />
  The most known use of procedural generation is terrain, biomes, and ecosystems dynamic creation.
  _Minecraft_ is a good example of that. Each world created is extremely vast and unique.

- ## Dynamic Level Design <br />
  <ImagesGrid columns={2} images={[{src:"/images/blog/procedural-generation/3.webp"}, {src:"/images/blog/procedural-generation/4.gif"}]} />
  Especially in roguelite games, procedural generation is used to create the dynamic level designs. 
  In _The binding of Isaac_, for example, rooms are designed by hand, but their layout is dynamically generated, 
  making each run unique.

- ## Texture and Asset Creation <br />
  <ImagesGrid columns={2} images={[{src:"/images/blog/procedural-generation/5.jpg"}, {src:"/images/blog/procedural-generation/6.jpg"}]} />
  Creating visual details on a massive scale can be overwhelming, but procedural generation makes it manageable. 
  Surfaces, patterns, and objects can be generated dynamically, ensuring that even the smallest details contribute 
  to a world‚Äôs uniqueness. This approach adds richness without requiring endless manual work.

- ## NPC Behavior and Quests <br />
  NPC's can modulate their dialogues, movements, routines, and behavior towards the player, 
  to make them seem more realistic. good examples are Skyrim or RDR2.
  
<SpacerM />

as you've seen, procedural generation is involved in almost every aspect of video game creation. 
Hovewer, in this article, we're going to understand how it works through the example of a **world creation**.
So where do we start ?

# Random !

The first step is of course to create randomness, but not just any kind of randomness.

<SpacerS />

For many applications, pure 
randomness is too chaotic and disconnected. What we often need is **randomness with 
structure**, a type of controlled variation that feels smooth and natural.

<SpacerM />

<BarChartRandom />

<SpacerM />

Take the example above, the chart illustrates pure random values. 
These values are entirely **independent of each other**, resulting in 
abrupt changes. While this type of randomness can 
be useful in certain scenarios, it often falls short when it comes to 
simulating natural or organic patterns.

<SpacerM />

<BarChartProcedural />

<SpacerM />

This chart showcases a more structured approach known as **Perlin noise**, 
a technique among others that introduces a sense of continuity. By ensuring 
**neighboring values are similar**, it produces smoother transitions that are ideal 
for generating lifelike textures, flowing landscapes, and organic forms.

<SpacerM />

## The Perlin Noise

The Perlin noise is one of the most popular algorithms for procedural generation. 
Its ability to produce smooth and continuous variations 
has made it a solution for many applications, let‚Äôs take a closer look at how it works:

<SpacerM />


On a digital canvas, each pixel is assigned a brightness value **between 0 and 100**, 
with 0 representing pure black and 100 pure white. However, as we‚Äôve seen, it‚Äôs 
not just about assigning random values to each pixel. There‚Äôs a gradual transition 
between neighboring values, creating smooth changes across the canvas :

<SpacerM />

<PerlinNoiseGenerator />

<SpacerM />

If you want to dive deeper into Perlin noise and understand how it's generated, 
I recommend reading <CustomLink isExternal href="https://rtouti.github.io/graphics/perlin-noise-algorithm">this article</CustomLink>from Raouf Touti.

<SpacerM />

We will use this algorithm for the next steps, but be aware that many others exist for various purposes.


# üå± The Seed

Have you noticed the _"seed"_ field with a value of 42 in the component above? <br />
Try changing it and see what happens.

<SpacerM />

When you alter the seed, the generated noise shifts entirely. This happens because the 
seed acts as the starting point for the random number generator that powers the procedural 
generation algorithm.


<Callout> The seed 42 will always generate the same result from the algorithm. Think of it as the DNA of your noise,
the seed ensures that random patterns can be reproduced. </Callout>

You may be familiar with this concept if you ever played Minecraft. Using the same seed 
as your friend generates identical worlds, allowing you to explore the same terrain.

# Other parameters (changer le nom)
- Scale
- frequency
- persistence
- Octave

# Practical example: Building a terrain

# Practical example: ...

# Practical example: ...

# Conclusion

Cet article a √©t√© pens√© comme une porte d'entr√©e dans le monde de la g√©n√©ration proc√©durale, nous avons
vu les fondamentaux de son fonctionnement. Si le coeur vous en dit, je vous
recommande vivement d'aller plus loin dans votre apprentissage et de tenter de faire de la g√©n√©ration 
proc√©durale par vous m√™me, vous trouverez une infinit√© de ressources sur internet pour tout 
les niveaux et toutes les applications !

<SpacerM />

En attendant, si vous voulez tester vos conaissances acquises sur cet article, vous pouvez
tenter de faire un perfect sur ce quizz :
