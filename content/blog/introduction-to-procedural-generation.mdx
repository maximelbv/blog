---
title: "The Procedural Generation: From Randomness to Realism"
type: "article"
description: "Learn how procedural generation uses algorithms to craft unique landscapes, textures, and environments through hands-on examples"
date: 2024-11-05
image: /images/procedural-generation.jpg
tags: ["procedural generation", "beginner friendly"]
category: Computer graphics
index: []
published: true
---
<Callout className={'!mt-0'}>‚òùÔ∏è This article is designed for newcomers and tech-savvy pros alike, with no prerequisites required to get started.</Callout>

In this article, we explore what procedural generation is and how it‚Äôs applied to create virtual worlds.
This is not a step-by-step tutorial but rather an opportunity to demystify the concept and 
inspire curiosity about its possibilities.

<SpacerM />

Procedural generation is a technique used in game development to create content algorithmically 
instead of manually. It allows developers to produce environments, objects, and experiences that 
feel organic without designing every element by hand. This approach has transformed how games are 
built, balancing creativity with automation.

# Use cases

- ## World generation <br />
  <ImagesGrid columns={2} images={[{src:"/images/blog/procedural-generation/2.webp"}, {src:"/images/blog/procedural-generation/1.png"}]} />
  The most known use of procedural generation is terrain, biomes, and ecosystems dynamic creation.
  _Minecraft_ is a good example of that. Each world created is unique.

- ## Dynamic Level Design <br />
  <ImagesGrid columns={2} images={[{src:"/images/blog/procedural-generation/3.webp"}, {src:"/images/blog/procedural-generation/4.gif"}]} />
  Especially in roguelite games, procedural generation is used to create the dynamic level designs. 
  In _The binding of Isaac_, for example, rooms are designed by hand, but their layout is dynamically generated, 
  making each run unique.

- ## Texture and Asset Creation <br />
  <ImagesGrid columns={2} images={[{src:"/images/blog/procedural-generation/5.jpg"}, {src:"/images/blog/procedural-generation/6.jpg"}]} />
  Creating visual details on a massive scale can be overwhelming, but procedural generation makes it manageable. 
  Surfaces, patterns, and objects can be generated dynamically, ensuring that even the smallest details contribute 
  to a world‚Äôs uniqueness. This approach adds richness without requiring endless manual work.

- ## NPC Behavior and Quests <br />
  <ImagesGrid columns={2} images={[{src:"/images/blog/procedural-generation/7.avif"}, {src:"/images/blog/procedural-generation/8.png"}]} />
  NPC's can modulate their dialogues, movements, routines, and behavior towards the player, 
  to make them seem more realistic. good examples are Skyrim or RDR2.
  
<SpacerM />

as you've seen, procedural generation is involved in almost every aspect of video game creation. 
Hovewer, in this article, we're going to understand how it works through the example of a **world creation**.
So where do we start ?

# Step 1 : Random !

The first step is of course to create randomness, but not just any kind of randomness.

<SpacerS />

For many applications, pure 
randomness is too chaotic and disconnected. What we often need is **randomness with 
structure**, a type of controlled variation that feels smooth and natural.

<SpacerM />

<BarChartRandom />

<SpacerM />

Take the example above, the chart illustrates pure random values. 
These values are entirely **independent of each other**, resulting in 
abrupt changes. While this type of randomness can 
be useful in certain scenarios, it often falls short when it comes to 
simulating natural or organic patterns.

<SpacerM />

<BarChartProcedural />

<SpacerM />

This chart showcases a more structured approach known as **Perlin noise**, 
a technique among others that introduces a sense of continuity. By ensuring 
**neighboring values are similar**, it produces smoother transitions that are ideal 
for generating lifelike textures, flowing landscapes, and organic forms.

<SpacerM />

## Understand what is a noise

In the context of procedural generation, a noise is a type of **mathematical function**
that generates values distributed across a space, with a certain continuity and coherence.

<SpacerM />

The **Perlin noise** that we used is one of them. 
Its ability to produce smooth and continuous variations 
has made it a solution for many applications, let‚Äôs take a closer look at how it works:

<SpacerM />


On a digital canvas, each pixel is assigned a brightness value **between 0 and 100**, 
with 0 representing pure black and 100 pure white. However, as we‚Äôve seen, it‚Äôs 
not just about assigning random values to each pixel. There‚Äôs a gradual transition 
between neighboring values, creating smooth changes across the canvas :

<SpacerM />

<PerlinNoiseGenerator />

<SpacerM />

If you want to dive deeper into Perlin noise and understand how it's generated, 
I recommend reading <CustomLink isExternal href="https://rtouti.github.io/graphics/perlin-noise-algorithm">this article</CustomLink>from Raouf Touti.

<SpacerM />

We will use this algorithm for the next steps, but be aware that many others exist for various purposes:

<ImagesGrid columns={2} images={[
  {src:"/images/blog/procedural-generation/fractal-noise.jpg", alt: "Fractal noise"},
  {src:"/images/blog/procedural-generation/worley-noise.jpg", alt: "Worley noise"},
  {src:"/images/blog/procedural-generation/white-noise.avif", alt: "White noise (yes the one from the TV's !)"},
  {src:"/images/blog/procedural-generation/simplex-noise.jpg", alt: "Simplex noise"},
]}/>

## üå± The Seed

Have you noticed the _"seed"_ field with a value of 42 in the component above? <br />
Try changing it and see what happens.

<SpacerS />

When you change the seed, you change the entire noise pattern because the seed is the initial 
input that drives the generator. 

<SpacerS />

If you keep the same seed, like "42" you‚Äôll always 
get the same result, similar to how DNA defines consistent traits. This reproducibility is crucial 
to recreate identical patterns later on.

<SpacerS />

You may be familiar with this concept if you ever played Minecraft. Using the same seed 
as your friend generates identical worlds, allowing you to explore the same terrain.

<CustomImage href="/images/blog/procedural-generation/minecraft-seed-menu.png" />

# Step 2 : Turning noise into relief

Now that we have the noise, we can move on to the exciting part: transforming 
it into a realistic terrain. By mapping the grayscale values of noise to heights, 
we can create mountains, valleys, and plateaus, giving structure and depth to our virtual 
worlds. Let‚Äôs dive into the essentials of how this works.

In general, these tools come with ready-to-use terrain generators, but if you want 
to try it out for yourself, you can follow this very quick tutorial from CGMatter : <CustomLink isExternal href='https://www.youtube.com/watch?v=P-j6X4HDuT8'>Blender Terrain in 2 CLICKS!</CustomLink> 


# Conclusion

Cet article a √©t√© pens√© comme une porte d'entr√©e dans le monde de la g√©n√©ration proc√©durale, nous avons
vu les fondamentaux de son fonctionnement. Si le coeur vous en dit, je vous
recommande vivement d'aller plus loin dans votre apprentissage et de tenter de faire de la g√©n√©ration 
proc√©durale par vous m√™me, vous trouverez une infinit√© de ressources sur internet pour tout 
les niveaux et toutes les applications !

<SpacerM />

En attendant, si vous voulez tester vos conaissances acquises sur cet article, vous pouvez
tenter de faire un perfect sur ce quizz :
