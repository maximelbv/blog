---
title: "The Procedural Generation: From Randomness to Realism"
type: "article"
description: "Learn how procedural generation uses algorithms to craft unique landscapes, textures, and environments through hands-on examples"
date: 2024-11-05
image: /images/blog/procedural-generation/thumbnail.jpg
tags: ["procedural generation", "beginner friendly"]
category: Computer graphics
index: []
published: true
---
<Callout className={'!mt-0'}>‚òùÔ∏è This article is designed for newcomers and tech-savvy pros alike, with no prerequisites required to get started.</Callout>

In this article, we explore what procedural generation is and how it‚Äôs applied to create virtual worlds.
This is not a step-by-step tutorial but rather an opportunity to demystify the concept and 
inspire curiosity about its possibilities.

<SpacerM />

Procedural generation is a technique used in game development to create content algorithmically 
instead of manually. It allows developers to produce environments, objects, and experiences that 
feel organic without designing every element by hand.

# Use cases

- ## World generation <br />
  <ImagesGrid columns={2} images={[{src:"/images/blog/procedural-generation/2.webp"}, {src:"/images/blog/procedural-generation/1.png"}]} />
  The most known use of this process is terrain, biomes, and ecosystems dynamic creation.
  _Minecraft_ is a good example of that. Each new world is unique, thanks to the procedural generation.

- ## Dynamic Level Design <br />
  <ImagesGrid columns={2} images={[{src:"/images/blog/procedural-generation/3.webp"}, {src:"/images/blog/procedural-generation/4.gif"}]} />
  Especially in roguelite games, procedural generation is used to create the dynamic level designs. 
  In _The binding of Isaac_, for example, rooms are designed by hand, but their layout is dynamically generated, 
  making each run unique.

- ## Texture and Asset Creation <br />
  <ImagesGrid columns={2} images={[{src:"/images/blog/procedural-generation/5.jpg"}, {src:"/images/blog/procedural-generation/6.jpg"}]} />
  Creating visual details on a massive scale can be overwhelming, but procedural generation makes it manageable. 
  Surfaces, patterns, and objects can be generated dynamically, ensuring that even the smallest details contribute 
  to a world‚Äôs uniqueness. This approach adds richness without requiring endless manual work.

- ## NPC Behavior and Quests <br />
  <ImagesGrid columns={2} images={[{src:"/images/blog/procedural-generation/7.avif"}, {src:"/images/blog/procedural-generation/8.png"}]} />
  NPC's can modulate their dialogues, movements, routines, and behavior towards the player, 
  to make them seem more realistic. good examples are Skyrim or RDR2.
  
<SpacerM />

as you've seen, procedural generation is involved in almost every aspect of video game creation. 
Hovewer, in this article, we're going to understand how it works through the example of a **world creation**.
So where do we start ?

# Step 1 : Random !

The first step is of course to create randomness, but not just any kind of randomness.

<SpacerS />

For many applications, pure randomness is too chaotic and disconnected. Take the example below,
the chart illustrates pure random values. 
These values are entirely **independent of each other**, resulting in 
abrupt changes.

<SpacerM />

<BarChartRandom />

<SpacerM />

While this type of randomness can 
be useful in certain scenarios, it often falls short when it comes to 
simulating natural or organic patterns. What we often need is **randomness with 
structure**, a type of controlled variation that feels smooth and natural :

<SpacerM />

<BarChartProcedural />

<SpacerM />

This chart showcases a more structured approach known as **Perlin noise**, 
a technique among others that introduces a sense of continuity. By ensuring 
**neighboring values are similar**, it produces smoother transitions that are ideal 
for generating lifelike textures, flowing landscapes, and organic forms.

<SpacerM />

## Understand what is a noise

In the context of procedural generation, a noise is a type of **mathematical function**
that generates values distributed across a space, with a certain continuity and coherence.
You don‚Äôt need to understand how it‚Äôs made, just how it works and how it can be applied.

<SpacerM />

The **Perlin noise** that we used is one of them. 
Its ability to produce smooth and continuous variations 
has made it a solution for many applications, let‚Äôs take a closer look at how it works:

<SpacerM />


On a digital canvas, each pixel is assigned a brightness value **between 0 and 100**, 
with 0 representing pure black and 100 pure white. However, as we‚Äôve seen, it‚Äôs 
not just about assigning random values to each pixel. There‚Äôs a gradual transition 
between neighboring values, creating smooth changes across the canvas.

<SpacerM />

Hover your mouse over the image to zoom in and see its details. You'll notice each pixel's 
brightness value and the smooth transitions between them :

<SpacerM />

<PerlinNoiseGenerator />

<SpacerM />

That is basically the concept of Perlin noise. However, if you‚Äôre curious about how it‚Äôs made, 
I recommend reading <CustomLink isExternal href="https://rtouti.github.io/graphics/perlin-noise-algorithm">this article</CustomLink>from Raouf Touti.

<SpacerM />

We will rely on this algorithm for the next steps, but keep in mind that 
there are many others designed for different purposes, some examples are :

<ImagesGrid columns={2} images={[
  {src:"/images/blog/procedural-generation/fractal-noise.jpg", alt: "Fractal noise"},
  {src:"/images/blog/procedural-generation/worley-noise.jpg", alt: "Worley noise"},
  {src:"/images/blog/procedural-generation/white-noise.avif", alt: "White noise (yes the one from the TV's !)"},
  {src:"/images/blog/procedural-generation/simplex-noise.jpg", alt: "Simplex noise"},
]}/>

## üå± The Seed

We won‚Äôt dive too deep into the details, but before moving on, I want to introduce an 
important concept in noise generation: **the seed**.

<SpacerS />

You may have noticed the "seed" field with the value 42 in the perlin noise generator component,
but what is this ? and why does the noise change when i change the seed value ?

<AutoplayVideo src="/images/blog/procedural-generation/seed-change.mov" />

When you change the seed, you change the entire noise pattern because the seed is the **initial 
input that drives the generator**. 

<SpacerS />

Think of it like planting a tomato seed in a garden : it will always grow into a tomato plant. 
If you plant a sunflower seed instead, you‚Äôll get a completely different result. 

<SpacerS />

In procedural generation, the seed works the same way. It‚Äôs the starting point that determines 
the entire outcome. Keep the seed the same, and you‚Äôll always recreate the same result; change it, 
and you‚Äôll get something entirely new.
<SpacerS />

You may be familiar with this concept if you ever played Minecraft. Using the same seed 
as your friend generates identical worlds, allowing you to explore the same terrain.

<CustomImage href="/images/blog/procedural-generation/minecraft-seed-menu.png" />

# Step 2 : Turning noise into relief

# Conclusion

In this article, we demystified what procedural generation is through the example of 
one of its applications, but as you'd expect, procedural generation goes far beyond that.

<SpacerS />

If this introduction has caught your attention, i highly encourage you to dive in and experiment 
procedural generation for yourself. You'll find a wealth of content online for all levels and 
applications.

<SpacerS />

In the meantime, if you'd like to test your knowledge of this article, you can give this 
quizz a try : 
